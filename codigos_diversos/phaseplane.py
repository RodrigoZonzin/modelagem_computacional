# -*- coding: utf-8 -*-
"""Phaseplane.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1EFEK4fr2VgFrrWelSMeoAkEZy87YyPzN
"""

import matplotlib.pyplot as plt
import numpy as np
import sympy as sp
from sympy.utilities.lambdify import lambdify
import scipy.optimize as opt
from sympy import diff
from sympy import sqrt
from matplotlib.backends.backend_pdf import PdfPages
import seaborn
import decimal as dc
dc.getcontext().prec = 2

u_key = "H"
v_key = "P"
u = sp.Symbol(u_key)
v = sp.Symbol(v_key)
variables = [u,v]

r = 0.2
a = 0.02
m = 0.5

def dudt(u,v):
    return r*u - a*u*v

def dvdt(u,v):
    return a*u*v - m*v
    
U = dudt(u,v)
V = dvdt(u,v)
UEqual = sp.Eq(U, 0.)
VEqual = sp.Eq(V, 0.)

eqMat = sp.Matrix([ U, V ])
Mat = sp.Matrix([ u, v ])
jacMat = eqMat.jacobian(Mat)
print('Jacobian %s' % jacMat)

eqp = sp.solve((UEqual, VEqual),(u,v))
print("Equilibrium points: " + str(eqp))

MAX_U = 150
MAX_V = 150
N_POINTS = 500
x = np.linspace(0.0, MAX_U, N_POINTS)
y = np.linspace(0.0, MAX_V, N_POINTS)

fp_file = open('eqpoints.txt','w')
nullclinesFile = open('nullclines.txt','w')

intersects_eixou = []
intersects_eixov = []
funcoes_lambda_v = []
res_v = sp.solve(dvdt(u,v))
nullclinesFile.write('v-nullclines: %s' %str(res_v))
nullclinesFile.write('\n--------------------------\n')
for i in range(len(res_v)):
    for key in res_v[i]:
        if str(key) == v_key:
            funcoes_lambda_v.append(lambdify(u, sp.sympify(res_v[i][v]),'numpy'))
        elif str(key) == u_key:
            funcoes_lambda_v.append(lambdify(v, sp.sympify(res_v[i][u]),'numpy'))

nullclines_v =  [[(k,k) for k in range(0,N_POINTS)] for p in range(0,len(res_v))]
for i in range(0,len(funcoes_lambda_v)):
    for j in range(0,N_POINTS):
        for key in res_v[i]:
            if str(key) == v_key:
                nullclines_v[i][j] = (x[j],funcoes_lambda_v[i](x[j]))
            elif str(key) == u_key:
                nullclines_v[i][j] = (funcoes_lambda_v[i](x[j]),x[j])

funcoes_lambda_u = []
res_u = sp.solve(dudt(u,v))
nullclinesFile.write('u-nullclines: %s' %str(res_u))
nullclinesFile.write('\n--------------------------\n')
for i in range(len(res_u)):
    for key in res_u[i]:
        if str(key) == v_key:
            funcoes_lambda_u.append(lambdify(u, sp.sympify(res_u[i][v]),'numpy'))
        elif str(key) == u_key:
            funcoes_lambda_u.append(lambdify(v, sp.sympify(res_u[i][u]),'numpy'))

nullclines_u =  [[(k,k) for k in range(0,N_POINTS)] for p in range(0,len(res_u))]

for i in range(0,len(funcoes_lambda_u)):
    for j in range(0,N_POINTS):
        for key in res_u[i]:
            if str(key) == v_key:
                nullclines_u[i][j] = (x[j],funcoes_lambda_u[i](x[j]))
            elif str(key) == u_key:
                nullclines_u[i][j] = (funcoes_lambda_u[i](x[j]),x[j])

def eigenvalues(uvalue, vvalue):
    lambda_dF_f = lambdify(variables,diff(U,u))
    a11 = lambda_dF_f(uvalue,vvalue)

    lambda_dF_b = lambdify(variables,diff(U,v))
    a12 = lambda_dF_b(uvalue,vvalue)

    lambda_dB_f = lambdify(variables,diff(V,u))
    a21 = lambda_dB_f(uvalue,vvalue)

    lambda_dB_b = lambdify(variables,diff(V,v))
    a22 = lambda_dB_b(uvalue,vvalue)

    tr = a11 + a22
    det = a11*a22 - a12*a21
    print('Trace = ' + str(tr))
    print('Determinant = ' + str(det))
    tr2_4d = np.power(tr,2) - 4*det;
    print('Tr² -4Det = ' + str(tr2_4d))
    sqrt_tr2_4d = sqrt(tr2_4d)

    if isinstance(sqrt_tr2_4d,complex):
        if(tr < 0):
            fp_file.write('O ponto de equilíbrio em %s, %s é do tipo espiral sumidouro. Ele é estável.' % (uvalue,vvalue) + "\n")
        elif(tr > 0):
            fp_file.write('O ponto de equilíbrio em %s, %s é do tipo espiral fonte. Ele é instável.' % (uvalue,vvalue) + "\n")
        elif (tr == 0):
            fp_file.write('O ponto de equilíbrio em %s, %s é do tipo centro.' % (uvalue,vvalue) + "\n")
    else:
        if(det < 0):
            fp_file.write('O ponto de equilíbrio em %s, %s é do tipo sela.' % (uvalue,vvalue) + "\n")
        elif (tr < 0):
            fp_file.write('O ponto de equilíbrio em %s, %s é do tipo sumidouro. Ele é estável.' % (uvalue,vvalue) + "\n")
        elif(tr > 0):
            fp_file.write('O ponto de equilíbrio em %s, %s é do tipo fonte. Ele é instável.' % (uvalue,vvalue) + "\n")
        else:
            fp_file.write('O ponto de equilíbrio em %s, %s é do tipo centro.' % (uvalue,vvalue) + "\n")

for x,y in eqp:
    eigenvalues(x,y)

nullclinesFile.close()
fp_file.close()

seaborn.set(style='ticks')
fig = plt.figure(figsize=(9,6))
ax = fig.gca()
ax.grid(True, which='both')
seaborn.despine(ax=ax, offset=0)

N_POINTS = 50
x = np.linspace(0.0, 50, N_POINTS)
y = np.linspace(0.0, 50, N_POINTS)
x1 , y1  = np.meshgrid(x,y)               
dx = dudt(x1,y1)
dy = dvdt(x1,y1)

i = 0
newdx = []
hipot = np.hypot(dx, dy)
M = (hipot)                        # norm growth rate
M[ M == 0] = 1.                                 # avoid zero division errors
dx /= M                                        # normalize each arrows
dy /= M
plt.quiver(x1, y1, dx, dy, color='silver', zorder=2)

params = {'legend.fontsize': 'small',
          'figure.figsize': (9, 6),
         'axes.labelsize': '14',
         'axes.titlesize':'14',
         'xtick.labelsize':'14',
         'ytick.labelsize':'14'}
plt.rcParams.update(params)

plt.axis([-0.5,30, -0.5, 30])
plt.xlabel("H",fontsize=14);
plt.ylabel("P",fontsize=14);

for i in range(0,len(nullclines_v)):
    if i == 0:
        plt.plot(*zip(*nullclines_v[i]), 'r', label='d'+ v_key + '/dt nullcline', zorder=1);
    else:
        plt.plot(*zip(*nullclines_v[i]), 'r', zorder=1);

for i in range(0,len(nullclines_u)):
    if i == 0:
        plt.plot(*zip(*nullclines_u[i]), 'g--', label='d' + u_key + '/dt nullcline', zorder=1);
    else:
        plt.plot(*zip(*nullclines_u[i]), 'g--', zorder=1);

plt.scatter(*zip(*eqp), marker='o', color='b', s=40, label='Equilibrium points', zorder=3)

leg = plt.legend(loc='best',frameon = 1)
frame = leg.get_frame()
frame.set_color('white')
frame.set_linewidth(0)
plt.show()
fig.savefig('phaseplane.png', format='png', bbox_inches='tight')